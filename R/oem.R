# oem.R - DESC
# mse/R/oem.R

# Copyright European Union, 2018
# Author: Ernesto Jardim (EC JRC) <ernesto.jardim@ec.europa.eu>
#         Iago Mosqueira (EC JRC) <iago.mosqueira@ec.europa.eu>
#
# Distributed under the terms of the European Union Public Licence (EUPL) V.1.1.


# perfect.oem {{{

#' A perfect observation of catch and abundances-at-age.
#'
#' This observation error model function generates a set of perfect observations
#' on catches, biology and abundance. Direct observations are made of the stock,
#' while a single age-structured index of abundance, in numbers, is created with
#' a fixed catchability of 0.01. *deviances* on either *stk$catch.n* or
#' *idx$index*, if given, are applied.
#'
#' This *oem* function generates a full observation time series every time step,
#' and does not append them to existing objects in *observations*.
#'
#' @param om An operating model, class *FLom* or *FLombf*.
#' @param observations A list of past observations, extended to the end of *om*, class *list*.
#' @param deviances A named list of observation deviances, class *list*.
#' @param args The mp dimensions arguments, as generated by `mp`, class *list*.
#' @param tracking Object to track module decisions and outputs, class *FLQuant*.
#'
#' @return A named *list* with elements *stk* (*FLStock*), *idx* (*FLIndices*), *deviances*, *observations* and *tracking*.
#'
#' @examples
#' # On FLom
#' data(ple4om)
#' obs <- perfect.oem(stock(om), deviances=NULL, observations=NULL,
#'   args=list(y0=1957, dy=2017), tracking=FLQuant())

perfect.oem <- function(stk, deviances, observations, args, tracking,
  biomass=FALSE, ...) {

  # DIMENSIONS
  y0 <- ac(args$y0)
  dy <- ac(args$dy)

  # GET perfect stock
	stk <- window(stk, start=y0, end=dy, extend=FALSE)

  # SIMPLIFY as with observations$stk
  dis <- dim(observations$stk)

  if(!is.null(dis)) {
    if(dis[3] == 1)
      stk <- nounit(stk)
    if(dis[4] == 1)
      stk <- noseason(stk)
  }

  # SET perfect FLIndex per stock
  if(biomass) {
    abu <- catch(stk) / fbar(stk)
    idx <- FLIndices(A=FLIndexBiomass(index=abu %/% abu[,1],
      sel.pattern=catch.sel(stk), index.q=expand(abu[,1],
        year=dimnames(abu)$year, fill=TRUE),
      effort=fbar(stk), range=c(startf=0, endf=0)))
  } else {
    idx <- FLIndices(A=FLIndex(index=stock.n(stk) * 0.01,
      catch.n=catch.n(stk), catch.wt=stock.wt(stk),
      sel.pattern=catch.sel(stk), index.q=stock.n(stk) %=% 1 / 0.01,
      effort=fbar(stk), range=c(startf=0, endf=0)))
  }

  # STORE observations
  observations$stk <- stk
  observations$idx <- idx

	list(stk=stk, idx=idx, observations=observations, tracking=tracking)

} # }}}

# sampling.oem {{{

#' @examples
#' data(ple4om)
#' oem@deviances$idx <- lapply(oem@observations$idx, function(x) index(x) %=% 0.1)
#' oem@deviances$stk <- FLQuants(catch.n=catch.n(stock(om)) %=% 0.1)
#' oem@observations$idx[[1]] <- propagate(oem@observations$idx[[1]], 25)
#' sampling.oem(stock(om), deviances=deviances(oem), observations=observations(oem),
#'   args=list(y0=2000, dy=2016, ay=2017, frq=1), tracking=FLQuant())

sampling.oem <- function(stk, deviances, observations, args, tracking, ...) {

  # DIMENSIONS
  y0 <- ac(args$y0)
  dy <- ac(args$dy)
  yrs <- ac(seq(args$y0, args$dy))

  # Data years
  dyrs <- ac(seq(args$dy - args$frq + 1, args$dy))

  # Assessment year
  ay <- ac(args$ay)

  # GET perfect stock
	stk <- window(stk, start=y0, end=dy, extend=FALSE)

  # TODO SIMPLIFY as with observations$stk
  dis <- dim(observations$stk)
  if(dis[3] == 1)
    stk <- nounit(stk)
  if(dis[4] == 1)
    stk <- noseason(stk)

  # --- STK

  if(!is.null(deviances$stk)) {

    # APPLY deviances to corresponding slot
    devs <- lapply(setNames(nm=names(deviances$stk)), function(x) {
      do.call(x, list(object=stk))[, dyrs] * deviances$stk[[x]][, dyrs] + 1
    })

    # ASSIGN devs to observations$stk slots in dyrs
    for(i in names(devs)) {
      slot(observations$stk, i)[, dyrs] <- devs[[i]]
    }

    # COMPUTE depending on inputs
    landings(observations$stk)[, dyrs] <- computeLandings(observations$stk[, dyrs])
    discards(observations$stk)[, dyrs] <- computeDiscards(observations$stk[, dyrs])

    catch(observations$stk)[, dyrs] <- computeCatch(observations$stk[, dyrs])

    # SHORTCUT 
    stock.n(observations$stk)[, dyrs] <- stock.n(stk)[, dyrs]
    harvest(observations$stk)[, dyrs] <- harvest(stk)[, dyrs]

    # SET output stock
    stk <- observations$stk[, yrs]
  }

  # --- IDX

  idx <- observations$idx
  
  # CHOOSE indices to be updated (maxyear >= dy)
  upi <- unlist(lapply(idx, function(x) unname(range(x, "maxyear")) > args$dy))

  # lapply(idx[upi], index.q)
  if(!is.null(deviances$idx)) {

    # APPLY survey() with deviances$idx as index.q

    idx[upi] <- Map(function(x, y) {
      
      # CREATE survey obs
      res <- survey(stk[, dyrs], x[, dyrs], sel=sel.pattern(x)[, dyrs],
        index.q=y[, dyrs])

      # FLATTEN units, should not be surveyed separately
      res <- unitSums(res)
    
      # SET 0s to min / 2
      res[res == 0] <- min(res[res > 0] / 2)

      # ASSIGN in dyrs    
      index(x)[, dyrs] <- res

      return(window(x, end=dy))

    }, x=idx[upi], y=deviances$idx[upi])

    for(i in seq(idx[upi]))
      observations$idx[upi][[i]][, dyrs] <- idx[upi][[i]][, dyrs]

  } else {
    idx <- observations$idx
  }

  # return
  list(stk=stk, idx=idx, observations=observations, tracking=tracking)

} # }}}

# default.oem {{{
default.oem <- function(stk) {
  
  # observations match OM
  obs <- list(idx=FLIndices(A=as(stk, 'FLIndex')), stk=stk)

  # deviances are NULL
  devs <- list(idx=FLQuants(index.q=index.q(obs$idx$A) %=% 1),
    stk=FLQuants(catch.n=catch.n(obs$stk) %=% 1))

  # method is perfect.oem

  return(FLoem(method=perfect.oem, observations=obs, deviances=devs))
}
# }}}
